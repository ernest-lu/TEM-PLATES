template<typename T, typename Merge = plus<T>>
struct lazy_seg{
	int n;
	vector<T> tr, lazy_inc, lazy_ass, tag_inc, tag_ass;
	Merge merge;
	
	void pull(int z) {
		tr[z] = merge(tr[2 * z], tr[2 * z + 1]);
	};
	
	lazy_seg(int n) : n(n), tr(4 * n + 5), lazy_inc(4 * n + 5), lazy_ass(4 * n + 5), tag_inc(4 * n + 5), tag_ass(4 * n + 5), merge(Merge()) {}
	
	lazy_seg(vector<T> a) : lazy_seg((int)a.size()) {
		function<void (int, int, int)> build = [&](int z, int l, int r) {
			if (l == r) {
				tr[z] = a[l - 1];
				return;
			}
			int m = (l + r) >> 1;
			build(2 * z, l, m);
			build(2 * z + 1, m + 1, r);
			pull(z);
		};
		build(1, 1, n);
	}
	
	T f(int l, int r) {
		return r - l + 1; //change on operation
	}
	
	void push(int z, int l, int r) {
		if (tag_ass[z]) {
			tr[z] = f(l, r) * lazy_ass[z];
             if (l < r) F0R (i, 2) {
             	  lazy_ass[2 * z + i] = lazy_ass[z];
             	  tag_ass[2 * z + i] = true;
             }
		} else if (tag_inc[z]) {
			tr[z] += f(l, r) * lazy_inc[z];
			if (l < r) F0R (i, 2) {
				if (tag_ass[2 * z + i]) {
					lazy_ass[2 * z + i] += lazy_inc[z];
				} else {					
					lazy_inc[2 * z + i] += lazy_inc[z];
					tag_inc[2 * z + i] = true;
				}
			}
		}
		tag_ass[z] = false;
		tag_inc[z] = false;
		lazy_inc[z] = T(0);
		lazy_ass[z] = T(0);
	}
	
	void up_ass(int z, int l, int r, int ql, int qr, T val) {
    	push(z, l, r);
        if (ql > qr) return;		
		if (ql == l && qr == r) {
			lazy_ass[z] = val;
			tag_ass[z] = true;
			push(z, l, r); 
			return;
		} 
		int m = (l + r) >> 1;
		up_ass(2 * z, l, m, ql, min(qr, m), val);
		up_ass(2 * z + 1, m + 1, r, max(ql, m + 1), qr, val);
		pull(z);
	};
	
	void up_inc(int z, int l, int r, int ql, int qr, T val) {
		push(z, l, r);
        if (ql > qr) return;     		
		if (ql == l && qr == r) {
			lazy_inc[z] += val;
			tag_inc[z] = true;
			push(z, l, r); 
			return;
		} 
		int m = (l + r) >> 1;
		up_inc(2 * z, l, m, ql, min(qr, m), val);
		up_inc(2 * z + 1, m + 1, r, max(ql, m + 1), qr, val);
		pull(z);
	};
	
	T query(int z, int l, int r, int ql, int qr) {
		push(z, l, r);
        if (ql > qr) return T(0);
		if (ql == l && qr == r) {
			return tr[z];
		}
		int m = (l + r) >> 1;
		return merge(
			query(2 * z, l, m, ql, min(qr, m)),
			query(2 * z + 1, m + 1, r, max(ql, m + 1), qr)
		);
	};
	
	void up_inc(int l, int r, T val) { return up_inc(1, 1, n, l, r, val); }
	void up_ass(int l, int r, T val) { return up_ass(1, 1, n, l, r, val); }
	T query(int l, int r) { return query(1, 1, n, l, r); }
};

template<typename T, typename Merge = plus<T>, typename LazyOp=LL>
struct lazy_seg {
	int n;
	vector<T> tr;
	vector<LazyOp> lazy_inc;
	vector<bool> tag_inc;
	Merge merge;
	
	void pull(int z) {
		tr[z] = merge(tr[2 * z], tr[2 * z + 1]);
	};
	
	lazy_seg(int n) : n(n), tr(4 * n + 5), lazy_inc(4 * n + 5), tag_inc(4 * n + 5), merge(Merge()) {}
	
	lazy_seg(vector<LL> a) : lazy_seg((int)a.size()) {
		function<void (int, int, int)> build = [&](int z, int l, int r) {
			if (l == r) {
				tr[z] = T(a[l]);
				return;
			}
			int m = (l + r) >> 1;
			build(2 * z, l, m);
			build(2 * z + 1, m + 1, r);
			pull(z);
		};
		build(1, 0, n - 1);
	}
	
	
	void push(int z, int l, int r) {
		if (tag_inc[z]) {
			tr[z].apply(lazy_inc[z]);
			if (l < r) F0R (i, 2) {				
				lazy_inc[2 * z + i] += lazy_inc[z];
				tag_inc[2 * z + i] = true;
			}
		}
		tag_inc[z] = false;
		lazy_inc[z] = 0LL;
	}
	
	void up_inc(int z, int l, int r, int ql, int qr, const LazyOp& val) {
		push(z, l, r);
        if (ql > qr) return;     		
		if (ql == l && qr == r) {
			lazy_inc[z] += val;
			tag_inc[z] = true;
			push(z, l, r); 
			return;
		} 
		int m = (l + r) >> 1;
		up_inc(2 * z, l, m, ql, min(qr, m), val);
		up_inc(2 * z + 1, m + 1, r, max(ql, m + 1), qr, val);
		pull(z);
	};
	
	void up_inc(int l, int r, const LazyOp& val) { return up_inc(1, 0, n - 1, l, r, val); }
	T query(int l, int r) { return query(1, 0, n - 1, l, r); }
};
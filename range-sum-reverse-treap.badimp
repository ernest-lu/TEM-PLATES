struct Node {
	//always push before u visit a node
	int val;
	int weight, size;
	bool rev;
	Node *left, *right;
	LL sum = 0;
	Node(int c) : val(c), weight(rand()), size(1), left(NULL), right(NULL), rev(false), sum(c) {}
 
} *root;
 
 
int size(Node *treap) {
	return treap ? treap->size : 0;
}

LL sum(Node* treap) {
	return treap ? treap->sum : 0LL;
}

void push(Node* treap) {
	if (treap == NULL) return;
	if (treap->rev == true) {
		swap(treap->left, treap->right);
		if (treap->left) 
			treap->left->rev ^= true;
		if (treap->right) 
			treap->right->rev ^= true;
	}
	treap->rev = false;
}

void pull(Node* treap) {
	if (treap == NULL) return;
	treap->size = 1 + size(treap->left) + size(treap->right);
	treap->sum = treap->val + sum(treap->left) + sum(treap->right);
}

 
void split(Node *treap, Node *&left, Node *&right, int val) {
 	push(treap);

	if (!treap) {
		left = right = NULL;
		return;
	}
 
	if (size(treap->left) < val) {
		split(treap->right, treap->right, right, val - size(treap->left) - 1);
		left = treap;
 
	} else {
		split(treap->left, left, treap->left, val);
		right = treap;
 
	}
	pull(treap);
}
 
void merge(Node *&treap, Node *left, Node *right) {
	push(left);
	push(right);	

	if (left == NULL) {
		treap = right;
		return;
	}
 
	if (right == NULL) {
		treap = left;
		return;
	}
 
	if (left->weight < right->weight) {
		merge(left->right, left->right, right);
		treap = left;
	} else {
		merge(right->left, left, right->left);
		treap = right;
	}
 
	pull(treap);
}
